// Вызывается каждый кадр после EventTick
const drawUI = () => {
    /* ПРИМЕР */
    const _texture = render.createTexture(_UI, 200, 200);
    // создаём текстуру (это пример, но лучше не вызывать каждый кадр)
    /* .createTexture(image, width, height)
    * image - изображение (должно быть квадратным)
    * width, height - ширина и высота изображения.
    Изображение будет растянуто под указаннуюширину и высоту.
    Исходное изображение должно быть квадратным! Вызывать желательно только 1 раз на каждое изображение
    при инициализации! */
    
    const _size = render.getCanvasSize(); // получаем размер экрана
    /* .getCanvasSize()
    * возвращает массив из двух элементов (ширина и высота экрана) */
    let _array;
    if (deltaTime <= 0.03) {
        _array = [
            {
                'pa': [_size[0] / 2, _size[1] / 2], 'pb': [_size[0] / 2 * 3, _size[1] / 2 * 3],
                'ta': [0.5, 0.5], 'tb': [1, 1]	
            }];
    } else {
        _array = [
            {
                'pa': [10, 10 ], 'pb': [110, 110], 'ta': [0, 0], 'tb': [1, 1]
            }];
    }
    _array = [
        {
            'pa': [_size[0] / 2, _size[1] / 2], 'pb': [_size[0] / 2 * 3, _size[1] / 2 * 3],
            'ta': [0.5, 0.5], 'tb': [1, 1]	
        },
        {
            'pa': [10, 10 ], 'pb': [110, 110], 'ta': [0, 0], 'tb': [1, 1]
        }];
        /* .drawObjects(texture, array)
        * texture - текстура, полученная из .createTexture
        * array - массив, состоящий из объектов вида:
        * {'pa': [paX, paY], 'pb': [pbX, pbY], 'ta': [taX, taY], 'tb': [tbX, tbY]}
            * pa - нижний левый угол позиции объекта
            * pb - верхний правый угол позиции объекта
            * ta - нижний левый угол текстурных координат
            * tb - ерхний правый угол текстурных координат
        Вызывать можно только после .render! */
        
        /* КОНЕЦ ПРИМЕРА */


        return true;
        // Возвращает true, если требуется перерисовка интерфейса
}